import { SelectionModel } from '@angular/cdk/collections';
import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, Injectable, Input, OnChanges, SimpleChanges } from '@angular/core';
import { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';
import { makeDeepCopyObject } from '@appDir/shared/utils/utils.helpers';
import { BehaviorSubject } from 'rxjs';
import { AutoGeneratedFolder } from '../models/AutoGeneratedFolder.model';

/**
 * Node for to-do item
 */
export class TodoItemNode {
	children: TodoItemNode[];
	item: AutoGeneratedFolder;
}

/** Flat to-do item node with expandable and level information */
export class TodoItemFlatNode {
	item: AutoGeneratedFolder;
	level: number;
	expandable: boolean;
	// show_files: boolean;
}

/**
 * The Json object for to-do list data.
 */
// const TREE_DATA: any[]=[];

/**
 * Checklist database, it can build a tree structured Json object.
 * Each node in Json object represents a to-do item or a category.
 * If a node is a category, it has children items and new items can be added under the category.
 */
@Injectable()
export class ChecklistDatabase {
	dataChange = new BehaviorSubject<TodoItemNode[]>([]);

	get data(): TodoItemNode[] { return this.dataChange.value; }

	constructor() {
		// this.initialize();
	}

	initialize(TREE_DATA: AutoGeneratedFolder[]) {
		// Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested
		//     file node as children.
		const data = this.buildFileTree(TREE_DATA, 0);

		// Notify the change.
		this.dataChange.next(data);
	}

	/**
	 * Build the file structure tree. The `value` is the Json object, or a sub-tree of a Json object.
	 * The return value is the list of `TodoItemNode`.
	 */
	buildFileTree(folders: AutoGeneratedFolder[], level: number, parent_id?: number): TodoItemNode[] {
		if(folders && folders.length) {
			return folders.map(folder => {
				let node = new TodoItemNode();
				let item = makeDeepCopyObject(folder) as AutoGeneratedFolder
				delete item.sub_folders
				item.parent_id = parent_id
				node.item = item;
				node.children = this.buildFileTree(("sub_folders" in folder)?folder.sub_folders:[], level + 1, parent_id || item.id)
				return node
			})
		}


		// return Object.keys(obj).reduce<TodoItemNode[]>((accumulator, key) => {
		//   const value = obj[key];
		//   const node = new TodoItemNode();
		//   node.item = key;

		//   if (value != null) {
		//     if (typeof value === 'object') {
		//       node.children = this.buildFileTree(value, level + 1);
		//     } else {
		//       node.item = value;
		//     }
		//   }

		//   return accumulator.concat(node);
		// }, []);
	}

	/** Add an item to to-do list */
	insertItem(parent: TodoItemNode, name: AutoGeneratedFolder) {
		if (parent.children) {
			parent.children.push({ item: name } as TodoItemNode);
			this.dataChange.next(this.data);
		}
	}

	updateItem(node: TodoItemNode, name: AutoGeneratedFolder) {
		node.item = name;
		this.dataChange.next(this.data);
	}
}

/**
 * @title Tree with checkboxes
 */
@Component({
	selector: 'folder-permission-tree',
	templateUrl: 'folder-permission-tree.component.html',
	styleUrls: ['folder-permission-tree.component.scss'],
	providers: [ChecklistDatabase]
})
export class FolderPermissionTreeComponent {


	@Input() data: { data: AutoGeneratedFolder[], result: { item: AutoGeneratedFolder }[] } = {} as any
	// @Input() result:{item:AutoGeneratedFolder}[]=[]
	ngOnChanges(simpleChange: SimpleChanges) {
		if (simpleChange.data) {
			this.checklistSelection.clear()
			if (this.data.data) {
				this._database.initialize(this.data.data)
			}
			// this.data.data.forEach(item=>item.is_checked?this.checklistSelection.select())
		}
		// console.log()
	}

	/** Map from flat node to nested node. This helps us finding the nested node to be modified */
	flatNodeMap = new Map<TodoItemFlatNode, TodoItemNode>();

	/** Map from nested node to flattened node. This helps us to keep the same object for selection */
	nestedNodeMap = new Map<TodoItemNode, TodoItemFlatNode>();

	/** A selected parent node to be inserted */
	selectedParent: TodoItemFlatNode | null = null;

	/** The new item's name */
	newItemName = '';

	treeControl: FlatTreeControl<TodoItemFlatNode>;

	treeFlattener: MatTreeFlattener<TodoItemNode, TodoItemFlatNode>;

	dataSource: MatTreeFlatDataSource<TodoItemNode, TodoItemFlatNode>;

	/** The selection for checklist */
	checklistSelection = new SelectionModel<TodoItemFlatNode>(true /* multiple */);

	constructor(private _database: ChecklistDatabase) {
		this.treeFlattener = new MatTreeFlattener(this.transformer, this.getLevel,
			this.isExpandable, this.getChildren);
		this.treeControl = new FlatTreeControl<TodoItemFlatNode>(this.getLevel, this.isExpandable);
		this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
		_database.dataChange.subscribe(data => {
			this.dataSource.data = data;
			this.selectAllIntial()
		});
	}

	getLevel = (node: TodoItemFlatNode) => node.level;

	isExpandable = (node: TodoItemFlatNode) => node.expandable;

	getChildren = (node: TodoItemNode): TodoItemNode[] => node.children;

	hasChild = (_: number, _nodeData: TodoItemFlatNode) => _nodeData.expandable;

	hasNoContent = (_: number, _nodeData: TodoItemFlatNode) => _nodeData.item === null;

	/**
	 * Transformer to convert nested node to flat node. Record the nodes in maps for later use.
	 */
	transformer = (node: TodoItemNode, level: number) => {
		const existingNode = this.nestedNodeMap.get(node);
		const flatNode = existingNode && existingNode.item === node.item
			? existingNode
			: new TodoItemFlatNode();
		flatNode.item = node.item;
		flatNode.level = level;
		flatNode.expandable = node.children && node.children.length > 0;
		this.flatNodeMap.set(flatNode, node);
		this.nestedNodeMap.set(node, flatNode);
		return flatNode;
	}

	/** Whether all the descendants of the node are selected. */
	descendantsAllSelected(node: TodoItemFlatNode): boolean {
		const descendants = this.treeControl.getDescendants(node);
		return descendants.length && descendants.every(child =>
			this.checklistSelection.isSelected(child)
		);
	}

	/** Whether part of the descendants are selected */
	descendantsPartiallySelected(node: TodoItemFlatNode): boolean {
		const descendants = this.treeControl.getDescendants(node);
		const result = descendants.some(child => this.checklistSelection.isSelected(child));
		return result && !this.descendantsAllSelected(node);
	}

	/** Toggle the to-do item selection. Select/deselect all the descendants node */
	todoItemSelectionToggle(node: TodoItemFlatNode, event, skipChild: boolean): void {
		if (event.checked) {
			this.checklistSelection.select(node);
		} else {
			this.checklistSelection.deselect(node)
		}
		node.item.show_files = event.checked
		if (skipChild) { return; }
		const descendants = this.treeControl.getDescendants(node);
		this.checklistSelection.isSelected(node)
			? this.checklistSelection.select(...descendants)
			: this.checklistSelection.deselect(...descendants);

		// Force update for the parent
		descendants.every(child => {
			// child.item.show_files=event.checked
			return this.checklistSelection.isSelected(child)
		}
		);
		descendants.forEach(child => child.item.show_files = event.checked)
		this.checkAllParentsSelection(node);
		setTimeout(() => {
			this.data.result = this.checklistSelection.selected
		}, 0);

	}

	/** Toggle a leaf to-do item selection. Check all the parents to see if they changed */
	todoLeafItemSelectionToggle(node: TodoItemFlatNode, event): void {
		if (event.checked) {
			this.checklistSelection.select(node);
		} else {
			this.checklistSelection.deselect(node)
		}
		node.item.show_files = event.checked
		this.checkAllParentsSelection(node);
		setTimeout(() => {
			this.data.result = this.checklistSelection.selected
		}, 0);


	}

	/* Checks all the parents when a leaf node is selected/unselected */
	checkAllParentsSelection(node: TodoItemFlatNode): void {
		let parent: TodoItemFlatNode | null = this.getParentNode(node);
		while (parent) {
			this.checkRootNodeSelection(parent);
			parent = this.getParentNode(parent);
		}
	}

	/** Check root node checked state and change it accordingly */
	checkRootNodeSelection(node: TodoItemFlatNode): void {
		const nodeSelected = this.checklistSelection.isSelected(node);
		const descendants = this.treeControl.getDescendants(node);
		const descAllSelected = descendants.every(child =>
			this.checklistSelection.isSelected(child)
		);
		if (nodeSelected && !descAllSelected && !this.descendantsPartiallySelected(node)) {
			this.checklistSelection.deselect(node);
		} else
		// if (!nodeSelected && descAllSelected)
		{
			this.checklistSelection.select(node);
		}
	}

	/* Get the parent node of a node */
	getParentNode(node: TodoItemFlatNode): TodoItemFlatNode | null {
		const currentLevel = this.getLevel(node);

		if (currentLevel < 1) {
			return null;
		}

		const startIndex = this.treeControl.dataNodes.indexOf(node) - 1;

		for (let i = startIndex; i >= 0; i--) {
			const currentNode = this.treeControl.dataNodes[i];

			if (this.getLevel(currentNode) < currentLevel) {
				return currentNode;
			}
		}
		return null;
	}

	/** Select the category so we can insert the new item. */
	addNewItem(node: TodoItemFlatNode) {
		const parentNode = this.flatNodeMap.get(node);
		this._database.insertItem(parentNode!, null);
		this.treeControl.expand(node);
	}

	/** Save the node to database */
	saveNode(node: TodoItemFlatNode, itemValue: AutoGeneratedFolder) {
		const nestedNode = this.flatNodeMap.get(node);
		this._database.updateItem(nestedNode!, itemValue);
	}
	showFile(event: { checked: boolean }, node: TodoItemFlatNode, isLeaf) {
		node.item.show_files = event.checked
		this.data.result = this.checklistSelection.selected
		if (event.checked || (!this.descendantsPartiallySelected(node) && !this.descendantsAllSelected(node) && !isLeaf)) {
			// this.checklistSelection.select(node)
			this.todoLeafItemSelectionToggle(node, event)
			// isLeaf ? this.todoLeafItemSelectionToggle(node, event) : this.todoItemSelectionToggle(node, event, true)
		} 
		// else if (!this.descendantsPartiallySelected(node) && !this.descendantsAllSelected(node)) {
		// 	// this.checklistSelection.deselect(node)
		// 	this.todoLeafItemSelectionToggle(node, event)
		// 	// isLeaf ? this.todoLeafItemSelectionToggle(node, event) : this.todoItemSelectionToggle(node, event, true)
		// }
		// !this.checklistSelection.isSelected(node)?this.checklistSelection.select(node):null
		this.data.result = this.checklistSelection.selected

	}
	selectAllIntial() {
		for (const node in this.dataSource.data) {
			const nodeData = this.transformer(this.dataSource.data[node], 0);
			const desendants = this.treeControl.getDescendants(nodeData);
			if (desendants.length) {
				desendants.forEach(val => {
					// ;
					// console.log(val);
					if (val.item.is_checked || val.item.show_files) {
						if (!this.treeControl.getDescendants(val).length) {
							this.checklistSelection.select(val);
							this.checkAllParentsSelection(val);
						}
					}
				});
			} else {
				nodeData.item.is_checked ? this.checklistSelection.select(nodeData) : null;
			}
		}
		this.data.result = this.checklistSelection.selected
	}

}

